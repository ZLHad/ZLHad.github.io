<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>3D ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Inter', 'Helvetica Neue', sans-serif;
        }

        canvas {
            display: block;
        }

        /* UI Panel */
        #ui-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 300px;
            height: 100vh;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(16px);
            border-right: 1px solid rgba(255, 255, 255, 0.08);
            transform: translateX(0);
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            color: #fff;
            padding: 24px;
            box-sizing: border-box;
            z-index: 100;
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        #ui-panel.collapsed {
            transform: translateX(-300px);
        }

        .toggle-btn {
            position: absolute;
            right: -48px;
            top: 24px;
            width: 48px;
            height: 48px;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: none;
            color: #fff;
            cursor: pointer;
            border-radius: 0 12px 12px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: 0.3s;
        }

        .toggle-btn:hover {
            background: rgba(30, 30, 30, 0.9);
        }

        h2 {
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 24px 0;
            background: linear-gradient(45deg, #00d2ff, #ff00a0);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        .scroll-area {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .scroll-area::-webkit-scrollbar {
            width: 4px;
        }

        .scroll-area::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }

        .control-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #00d2ff;
        }

        input[type="color"] {
            width: 100%;
            height: 36px;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
        }

        .scene-item {
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
            font-size: 14px;
        }

        .scene-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(2px);
        }

        .scene-item.active {
            background: rgba(0, 210, 255, 0.15);
            border-color: rgba(0, 210, 255, 0.4);
            color: #00d2ff;
        }

        .add-btn {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            color: #aaa;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 10px;
            font-size: 13px;
        }

        .add-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.4);
        }

        .del-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            border: none;
            background: rgba(255, 0, 0, 0.1);
            color: #ff4d4d;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            opacity: 0;
            transition: 0.2s;
        }

        .scene-item:hover .del-btn {
            opacity: 1;
        }

        .del-btn:hover {
            background: #ff4d4d;
            color: #fff;
        }

        /* Video hidden but needed for detection */
        #input_video {
            display: none;
        }

        /* Fullscreen btn */
        #fs-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 30px;
            transition: 0.3s;
            font-weight: 500;
            top: auto;
            /* override previous top */
        }

        #fs-btn:hover {
            background: #fff;
            color: #000;
        }

        /* Hand Cursor */
        #hand-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #00d2ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 90;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00d2ff;
            transition: opacity 0.3s;
            opacity: 0;
        }

        #hand-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            inset: 0;
            background: #050505;
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00d2ff;
            flex-direction: column;
            gap: 15px;
        }

        .loader-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 210, 255, 0.3);
            border-top-color: #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <div id="loader">
        <div class="loader-spinner"></div>
        <div>ç³»ç»Ÿåˆå§‹åŒ–ä¸­... è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <div id="hand-cursor"></div>

    <div id="ui-panel">
        <button class="toggle-btn" onclick="toggleUI()">â˜°</button>
        <h2>ç²’å­æ§åˆ¶å°</h2>

        <div class="control-group" style="display:flex; flex-direction:column; flex:1; overflow:hidden;">
            <label>å½“å‰åœºæ™¯</label>
            <div id="scene-list" class="scroll-area">
            </div>

            <div style="display:flex; gap:5px; margin-top:10px;">
                <select id="add-type-select"
                    style="flex:1; background:rgba(255,255,255,0.1); color:#fff; border:1px solid rgba(255,255,255,0.2); border-radius:4px; padding:8px; outline:none;">
                    <option value="custom_text">ğŸ”¤ è‡ªå®šä¹‰æ–‡å­—</option>
                    <option value="sphere">ğŸŒŒ æ˜Ÿäº‘çƒä½“</option>
                    <option value="cube">ğŸ§Š é‡å­ç«‹æ–¹</option>
                    <option value="torus">â™¾ï¸ è«æ¯”ä¹Œæ–¯ç¯</option>
                    <option value="dna">ğŸ§¬ åŒèºæ—‹ DNA</option>
                    <option value="heart">ğŸ’° çˆ±å¿ƒé‡‘å¸</option>
                    <option value="galaxy">ğŸŒ€ é“¶æ²³èºæ—‹</option>
                    <option value="wave">ğŸŒŠ ç²’å­æ³¢æµª</option>
                    <option value="ring">ğŸª åœŸæ˜Ÿå…‰ç¯</option>
                </select>
                <button class="add-btn" style="margin-top:0; width:auto; padding:0 15px;" onclick="handleAddScene()">+
                    æ·»åŠ </button>
            </div>

            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="add-btn"
                    style="margin-top:0; background:rgba(0,210,255,0.1); color:#00d2ff; border-color:rgba(0,210,255,0.3);"
                    onclick="saveScenes()">ä¿å­˜é…ç½®</button>
                <button class="add-btn" style="margin-top:0;" onclick="resetScenes()">é‡ç½®é»˜è®¤</button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰² A</label>
            <input type="color" id="colorA" value="#00d2ff">
        </div>
        <div class="control-group">
            <label>ç²’å­é¢œè‰² B</label>
            <input type="color" id="colorB" value="#ff00a0">
        </div>
        <div class="control-group">
            <label>æ’­æ”¾æ§åˆ¶</label>
            <div style="display:flex; align-items:center; margin-bottom:8px;">
                <input type="checkbox" id="autoplay-toggle" onchange="toggleAutoPlay(this.checked)" checked
                    style="width:20px; height:20px; margin-right:10px; cursor:pointer;">
                <span style="font-size:12px; color:#aaa;">è‡ªåŠ¨æ’­æ”¾ (é»˜è®¤é—´éš” 3s)</span>
            </div>
            <div style="display:flex; align-items:center; margin-bottom:15px;">
                <input type="checkbox" id="rotate-toggle" onchange="toggleRotation(this.checked)"
                    style="width:20px; height:20px; margin-right:10px; cursor:pointer;">
                <span style="font-size:12px; color:#aaa;">åœºæ™¯è‡ªåŠ¨æ—‹è½¬</span>
            </div>

            <label>ç²’å­æ•£å¼€ç¨‹åº¦ (æ‰‹åŠ¿æ§åˆ¶)</label>
            <input type="range" id="spread" min="0" max="2" step="0.01" value="0">
        </div>
        <p style="font-size: 11px; color: #666; margin-top: 50px;">
            æ“ä½œæŒ‡å—:<br>
            ğŸ‘Œ å¼ åˆ: æ§åˆ¶ç²’å­ç¼©æ”¾<br>
        </p>
    </div>

    <button id="fs-btn" onclick="toggleFullScreen()">å…¨å±æ¨¡å¼</button>
    <video id="input_video"></video>

    <script>
        /**
         * 1. åˆå§‹åŒ– & å…¨å±€å˜é‡
         */
        let scene, camera, renderer, particles, geometry, material;
        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;

        // é…ç½®
        const CONFIG = {
            particleCount: 15000,
            particleSize: 6.0,
            colorA: new THREE.Color('#00d2ff'),
            colorB: new THREE.Color('#ff00a0'),
            handInteractionStrength: 0
        };

        // åœºæ™¯åˆ—è¡¨ - é»˜è®¤åˆå§‹é›†
        // å¢åŠ  duration å­—æ®µï¼Œå•ä½ç§’ï¼Œé»˜è®¤ 3
        const DEFAULT_SCENES = [
            { name: "æ˜Ÿäº‘çƒä½“", type: "sphere", duration: 3 },
            { name: "é‡å­ç«‹æ–¹", type: "cube", duration: 3 },
            { name: "è«æ¯”ä¹Œæ–¯ç¯", type: "torus", duration: 3 },
            { name: "åŒèºæ—‹ DNA", type: "dna", duration: 3 },
            { name: "çˆ±å¿ƒé‡‘å¸", type: "heart", duration: 3 },
            { name: "å€’è®¡æ—¶ 3", type: "custom_text", content: "3", duration: 1 },
            { name: "å€’è®¡æ—¶ 2", type: "custom_text", content: "2", duration: 1 },
            { name: "å€’è®¡æ—¶ 1", type: "custom_text", content: "1", duration: 1 },
            { name: "ç”Ÿæ—¥ç¥ç¦", type: "text", duration: 10 } // æœ€åä¸€é¡µé»˜è®¤ä¹…ä¸€ç‚¹
        ];

        // å°è¯•ä» localStorage åŠ è½½
        let SCENES = [];
        try {
            const saved = localStorage.getItem('lizi_scenes');
            if (saved) {
                SCENES = JSON.parse(saved);
            } else {
                SCENES = JSON.parse(JSON.stringify(DEFAULT_SCENES));
            }
        } catch (e) {
            console.error("Load scenes failed", e);
            SCENES = JSON.parse(JSON.stringify(DEFAULT_SCENES));
        }

        let currentSceneIndex = 0;

        /**
         * 2. Three.js æ ¸å¿ƒè®¾ç½®
         */
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createParticles();
            animate();
            updateSceneListUI();
        }

        /**
         * 3. ç²’å­ç³»ç»Ÿ (Shader & Geometry)
         * ä½¿ç”¨ ShaderMaterial å®ç°é«˜æ€§èƒ½å’Œå¤æ‚çš„å˜æ¢æ•ˆæœ
         */
        function createParticles() {
            geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(CONFIG.particleCount * 3);
            const targets = new Float32Array(CONFIG.particleCount * 3); // ç›®æ ‡ä½ç½®ç”¨äº morph
            const randoms = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 500;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 500;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 500;

                randoms[i * 3] = Math.random();
                randoms[i * 3 + 1] = Math.random();
                randoms[i * 3 + 2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

            // GLSL Shader
            // ç”Ÿæˆ $ ç¬¦å·çº¹ç† for Shader use
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$', 16, 16);
            const dollarTexture = new THREE.CanvasTexture(canvas);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 0 }, // æ‰‹åŠ¿å¼ åˆæ§åˆ¶
                    uColorA: { value: CONFIG.colorA },
                    uColorB: { value: CONFIG.colorB },
                    uMixRatio: { value: 0 }, // åœºæ™¯åˆ‡æ¢è¿›åº¦
                    uSize: { value: CONFIG.particleSize },
                    uHandPos: { value: new THREE.Vector2(0, 0) },
                    uUseTexture: { value: 0 }, // 0: Circle, 1: Texture
                    uTexture: { value: dollarTexture }
                },
                vertexShader: `
                uniform float uTime;
                uniform float uScale;
                uniform float uMixRatio;
                uniform float uSize;
                uniform vec2 uHandPos;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                varying vec3 vColor;
                varying float vAlpha;

                // ç®€å•çš„å™ªå£°å‡½æ•°
                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                }

                void main() {
                    // ç²’å­æ··åˆï¼šä»å½“å‰ä½ç½®(position)åˆ°ç›®æ ‡ä½ç½®(target)
                    // æ³¨æ„ï¼šè¿™é‡Œçš„positionå®é™…ä¸Šæ˜¯ä¸Šä¸€å¸§çš„è®¡ç®—ç»“æœï¼Œä½†åœ¨ç®€å•Demoä¸­æˆ‘ä»¬é€šè¿‡uMixRatioæ§åˆ¶æ··åˆ
                    // æ›´å¥½çš„åšæ³•æ˜¯åŒBufferï¼Œè¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾ position æ˜¯åŸºç¡€å½¢æ€(Sphere)ï¼Œtarget æ˜¯å½“å‰å½¢æ€
                    
                    // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬åœ¨ JS ä¸­è®¡ç®—äº† shape å¹¶ä¼ å…¥ target
                    // çœŸæ­£çš„å˜å½¢åœ¨ JS ä¸­æ›´æ–° target buffer 
                    
                    vec3 finalPos = mix(position, target, uMixRatio);

                    // æ‰‹åŠ¿äº’åŠ¨ (æ‰‹çš„ä½ç½®æ’æ–¥ç²’å­)
                    // è¿™é‡Œç®€åŒ–ï¼Œä½¿ç”¨ uScale åšæ•´ä½“æ‰©æ•£
                    float dist = length(finalPos);
                    vec3 dir = normalize(finalPos);
                    
                    // å‘¼å¸æ•ˆæœ + æ‰‹åŠ¿æ”¾å¤§
                    float expansion = 1.0 + sin(uTime * 2.0 + dist * 0.05) * 0.05 + uScale;
                    finalPos *= expansion;

                    // éšæœºæ¼‚æµ®
                    finalPos.x += sin(uTime * aRandom.x + aRandom.y * 10.0) * 2.0;
                    finalPos.y += cos(uTime * aRandom.y + aRandom.z * 10.0) * 2.0;

                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    gl_PointSize = uSize * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;

                    // é¢œè‰²æ··åˆ
                    vAlpha = 1.0 - (dist / 200.0); // è¾¹ç¼˜æ·¡å‡º
                }
            `,
                fragmentShader: `
                uniform vec3 uColorA;
                uniform vec3 uColorB;
                uniform sampler2D uTexture;
                uniform float uUseTexture;
                varying float vAlpha;

                void main() {
                    if (uUseTexture > 0.5) {
                        vec4 texColor = texture2D(uTexture, gl_PointCoord);
                        if (texColor.a < 0.3) discard;
                        // æ··åˆé¢œè‰²
                        float d = distance(gl_PointCoord, vec2(0.5));
                        vec3 color = mix(uColorA, uColorB, d * 2.0);
                        gl_FragColor = vec4(color, texColor.a); 
                    } else {
                        float d = distance(gl_PointCoord, vec2(0.5));
                        if(d > 0.5) discard; // åœ†å½¢ç²’å­

                        vec3 color = mix(uColorA, uColorB, d * 2.0);
                        gl_FragColor = vec4(color, 1.0); // ç®€å•æ··åˆ
                    }
                }
            `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // åˆå§‹åŠ è½½ç¬¬ä¸€ä¸ªåœºæ™¯
            morphTo(0);
        }

        /**
         * 4. åœºæ™¯å˜å½¢é€»è¾‘ (Morphing Logic)
         */
        function getShapePositions(type) {
            const arr = new Float32Array(CONFIG.particleCount * 3);

            if (type === 'sphere') {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const r = 40 + Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    arr[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    arr[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    arr[i * 3 + 2] = r * Math.cos(phi);
                }
            } else if (type === 'cube') {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    arr[i * 3] = (Math.random() - 0.5) * 70;
                    arr[i * 3 + 1] = (Math.random() - 0.5) * 70;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 70;
                }
            } else if (type === 'torus') {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    const R = 40; const r = 15;
                    arr[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                    arr[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                    arr[i * 3 + 2] = r * Math.sin(v);
                }
            } else if (type === 'dna') {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // DNA Double Helix
                    const t = (i / CONFIG.particleCount) * 10 * Math.PI; // é«˜åº¦/åœˆæ•°
                    const radius = 60;
                    // Strand A
                    if (i % 2 === 0) {
                        arr[i * 3] = radius * Math.cos(t);
                        arr[i * 3 + 1] = (i / CONFIG.particleCount - 0.5) * 400; // height spread
                        arr[i * 3 + 2] = radius * Math.sin(t);
                    } else {
                        // Strand B (offset by PI)
                        arr[i * 3] = radius * Math.cos(t + Math.PI);
                        arr[i * 3 + 1] = (i / CONFIG.particleCount - 0.5) * 400;
                        arr[i * 3 + 2] = radius * Math.sin(t + Math.PI);
                    }

                    // Add some randomness to fill volume
                    arr[i * 3] += (Math.random() - 0.5) * 10;
                    arr[i * 3 + 1] += (Math.random() - 0.5) * 10;
                    arr[i * 3 + 2] += (Math.random() - 0.5) * 10;
                }
            } else if (type === 'heart') {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // Heart Shape Equation
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    // 3D volume by rotating or layering

                    const t = Math.random() * Math.PI * 2;
                    const u = Math.random(); // distribution

                    // 2D Heart curve base
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

                    // Extrude slightly in Z or make it a volume
                    const scale = 8 + Math.random() * 4;

                    arr[i * 3] = x * scale;
                    arr[i * 3 + 1] = y * scale;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 50; // Z thickness
                }
            } else if (type === 'galaxy') {
                // é“¶æ²³èºæ—‹ (Spiral Galaxy)
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 200;
                    // èºæ—‹æ–¹ç¨‹ï¼šå¢åŠ è§’åº¦éšåŠå¾„å˜åŒ–
                    const spiralAngle = angle + radius * 0.05;

                    arr[i * 3] = Math.cos(spiralAngle) * radius;
                    arr[i * 3 + 1] = (Math.random() - 0.5) * 20; // Flat disk
                    arr[i * 3 + 2] = Math.sin(spiralAngle) * radius;
                }
            } else if (type === 'wave') {
                // ç²’å­æ³¢æµª (Sine Wave Surface)
                const side = Math.sqrt(CONFIG.particleCount);
                const step = 400 / side;
                let idx = 0;
                for (let x = 0; x < side; x++) {
                    for (let z = 0; z < side; z++) {
                        if (idx >= CONFIG.particleCount) break;
                        const px = (x - side / 2) * step;
                        const pz = (z - side / 2) * step;
                        const py = Math.sin(x * 0.2) * 30 + Math.cos(z * 0.2) * 30;

                        arr[idx * 3] = px;
                        arr[idx * 3 + 1] = py;
                        arr[idx * 3 + 2] = pz;
                        idx++;
                    }
                }
            } else if (type === 'ring') {
                // åœŸæ˜Ÿå…‰ç¯ (Saturn Ring)
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // ç¯çš„èŒƒå›´
                    const inner = 120;
                    const outer = 220;
                    const r = inner + Math.random() * (outer - inner);
                    const theta = Math.random() * Math.PI * 2;

                    arr[i * 3] = r * Math.cos(theta);
                    arr[i * 3 + 1] = (Math.random() - 0.5) * 10; // very thin
                    arr[i * 3 + 2] = r * Math.sin(theta);

                    // ç¨å¾®å€¾æ–œä¸€ç‚¹
                    const x = arr[i * 3];
                    const y = arr[i * 3 + 1];
                    // simple rotation around Z
                    const tilt = 0.3;
                    arr[i * 3] = x * Math.cos(tilt) - y * Math.sin(tilt);
                    arr[i * 3 + 1] = x * Math.sin(tilt) + y * Math.cos(tilt);
                }
            } else if (type === 'text' || type === 'custom_text') {
                const str = type === 'text' ? "ç¥æ½˜é–\nç”Ÿæ—¥å¿«ä¹ï¼" : SCENES[currentSceneIndex].content;
                // ç”Ÿæˆæ–‡å­—ç²’å­åæ ‡
                const textPoints = generateTextParticles(str);
                // å°†ç‚¹åˆ†é…ç»™ç²’å­
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // å¦‚æœæ–‡å­—ç‚¹ä¸å¤Ÿï¼Œå°±éšæœºé£èˆ
                    const p = textPoints[i % textPoints.length];
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = p.z;
                }
            }
            return arr;
        }

        // å°†æ–‡å­—æ¸²æŸ“åˆ° Canvas å¹¶è·å–åƒç´ åæ ‡
        function generateTextParticles(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 500;
            canvas.height = 300;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 500, 300);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // å¤šè¡Œå¤„ç†
            const lines = text.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, 250, 100 + (i * 100));
            });

            const imageData = ctx.getImageData(0, 0, 500, 300);
            const points = [];
            // é‡‡æ ·ç‡
            const step = 2;

            for (let y = 0; y < 300; y += step) {
                for (let x = 0; x < 500; x += step) {
                    const alpha = imageData.data[(y * 500 + x) * 4]; // åªçœ‹Redé€šé“æˆ–Alpha
                    if (alpha > 128) {
                        points.push({
                            x: (x - 250) * 0.5, // ç¼©æ”¾å¹¶å±…ä¸­
                            y: -(y - 150) * 0.5, // Yè½´åè½¬
                            z: 0
                        });
                    }
                }
            }
            return points.length > 0 ? points : [{ x: 0, y: 0, z: 0 }];
        }

        // æ ¸å¿ƒåˆ‡æ¢é€»è¾‘
        function morphTo(index) {
            currentSceneIndex = index;
            const type = SCENES[index].type;
            const newPositions = getShapePositions(type);

            // GSAP åŠ¨ç”»è¿‡æ¸¡ uMixRatio æ˜¯å‡çš„ï¼Œæˆ‘ä»¬éœ€è¦çœŸå®åœ°æ›´æ–° geometry
            // è¿™é‡Œä¸ºäº†æ•ˆæœï¼Œç›´æ¥æ›´æ–° target attributeï¼ŒShader ä¼š mix position å’Œ target
            // ä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ç›´æ¥ç”¨ GSAP åŠ¨ç”»æ›´æ–°å½“å‰ä½ç½®æ•°ç»„åˆ°æ–°ä½ç½®æ•°ç»„

            const currentAttribute = geometry.attributes.position;
            // ä¿å­˜å½“å‰ä½ç½®ä½œä¸ºèµ·å§‹
            const startPositions = Float32Array.from(currentAttribute.array);

            const animObj = { t: 0 };

            gsap.to(animObj, {
                t: 1,
                duration: 1.5,
                ease: "power3.inOut",
                onUpdate: () => {
                    for (let i = 0; i < CONFIG.particleCount; i++) {
                        const idx = i * 3;
                        currentAttribute.array[idx] = startPositions[idx] + (newPositions[idx] - startPositions[idx]) * animObj.t;
                        currentAttribute.array[idx + 1] = startPositions[idx + 1] + (newPositions[idx + 1] - startPositions[idx + 1]) * animObj.t;
                        currentAttribute.array[idx + 2] = startPositions[idx + 2] + (newPositions[idx + 2] - startPositions[idx + 2]) * animObj.t;
                    }
                    currentAttribute.needsUpdate = true;
                },
                onComplete: () => {
                    // å¦‚æœæ˜¯ç”Ÿæ—¥åœºæ™¯ï¼Œæ·»åŠ é‡‘é’±ç‰¹æ•ˆ
                    if (type === 'text') triggerMoneyRain();
                }
            });

            // åˆ‡æ¢é¢œè‰²
            if (index === SCENES.length - 1) {
                // ç”Ÿæ—¥é…è‰²ï¼šé‡‘ + çº¢
                gsap.to(material.uniforms.uColorA.value, { r: 1, g: 0.84, b: 0, duration: 1 }); // Gold
                gsap.to(material.uniforms.uColorB.value, { r: 1, g: 0.2, b: 0.2, duration: 1 }); // Red
            } else {
                // æ¢å¤é»˜è®¤
                const cA = new THREE.Color(document.getElementById('colorA').value);
                const cB = new THREE.Color(document.getElementById('colorB').value);
                gsap.to(material.uniforms.uColorA.value, { r: cA.r, g: cA.g, b: cA.b, duration: 1 });
                gsap.to(material.uniforms.uColorB.value, { r: cB.r, g: cB.g, b: cB.b, duration: 1 });
            }

            // åˆ‡æ¢çº¹ç†æ¨¡å¼: å¦‚æœæ˜¯ Heart åœºæ™¯ (index 4)ï¼Œä½¿ç”¨é‡‘å¸çº¹ç†
            if (type === 'heart') {
                material.uniforms.uUseTexture.value = 1.0;
                gsap.to(material.uniforms.uSize, { value: CONFIG.particleSize * 3, duration: 1 }); // çº¹ç†éœ€è¦æ›´å¤§ä¸€ç‚¹
            } else {
                material.uniforms.uUseTexture.value = 0.0;
                gsap.to(material.uniforms.uSize, { value: CONFIG.particleSize, duration: 1 });
            }

            updateSceneListUI();
        }

        // é‡‘é’±é›¨ç‰¹æ•ˆ (çº¹ç† + æ—‹è½¬)
        let moneySystem;
        function triggerMoneyRain() {
            if (moneySystem) {
                scene.remove(moneySystem);
                moneySystem.geometry.dispose();
                moneySystem.material.dispose();
            }

            const count = 300;
            const moneyGeo = new THREE.BufferGeometry();
            const mPos = new Float32Array(count * 3);
            const mSpeed = new Float32Array(count);
            const mAxis = new Float32Array(count * 3); // æ—‹è½¬è½´
            const mAngle = new Float32Array(count);    // åˆå§‹è§’åº¦

            for (let i = 0; i < count; i++) {
                mPos[i * 3] = (Math.random() - 0.5) * 400;
                mPos[i * 3 + 1] = 200 + Math.random() * 200; // é¡¶éƒ¨å¼€å§‹
                mPos[i * 3 + 2] = (Math.random() - 0.5) * 100;
                mSpeed[i] = 1.0 + Math.random() * 2.0;

                mAxis[i * 3] = Math.random();
                mAxis[i * 3 + 1] = Math.random();
                mAxis[i * 3 + 2] = Math.random();
                mAngle[i] = Math.random() * Math.PI * 2;
            }

            moneyGeo.setAttribute('position', new THREE.BufferAttribute(mPos, 3));
            moneyGeo.setAttribute('speed', new THREE.BufferAttribute(mSpeed, 1));
            moneyGeo.setAttribute('axis', new THREE.BufferAttribute(mAxis, 3));
            moneyGeo.setAttribute('angle', new THREE.BufferAttribute(mAngle, 1));

            // ç”Ÿæˆ $ ç¬¦å·çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ï¿¥', 32, 32); // æˆ–è€… $
            const texture = new THREE.CanvasTexture(canvas);

            const moneyMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 20,
                map: texture,
                transparent: true,
                alphaTest: 0.5,
                opacity: 0.9
            });

            moneySystem = new THREE.Points(moneyGeo, moneyMat);
            moneySystem.userData = { active: true };
            scene.add(moneySystem);
        }

        /**
         * 5. MediaPipe Hands é›†æˆ
         */
        const videoElement = document.getElementById('input_video');

        let lastHandX = 0;
        let lastHandY = 0;
        let isSwiping = false;

        function onResults(results) {
            const loader = document.getElementById('loader');
            if (loader.style.display !== 'none') loader.style.display = 'none';

            const cursor = document.getElementById('hand-cursor');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 0. æ›´æ–°æ‰‹åŠ¿å…‰æ ‡ (å–ä¸­æŒ‡æ ¹éƒ¨ 9 ä½œä¸ºæ‰‹æŒä¸­å¿ƒå¤§æ¦‚ä½ç½®)
                const palm = landmarks[9];
                // MediaPipe åæ ‡æ˜¯ normalized [0,1]ï¼Œä¸” x æ˜¯é•œåƒçš„ï¼ˆè§†æƒ…å†µè€Œå®šï¼Œè¿™é‡Œæˆ‘ä»¬åšäº†é•œåƒç¿»è½¬ï¼‰
                // ç”»å¸ƒå®½ width, é«˜ height
                // æ³¨æ„ï¼šMediaPipe x=0 åœ¨å·¦è¾¹ï¼Œä½†é€šå¸¸ä¸ºäº†è‡ªæ‹é•œåƒä¹ æƒ¯ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„ç”»é¢å’Œæ‰‹æ˜¯åçš„ã€‚
                // è¿™é‡Œç›´æ¥æ˜ å°„: x -> 1-x
                const cursorX = (1 - palm.x) * window.innerWidth;
                const cursorY = palm.y * window.innerHeight;

                cursor.style.left = `${cursorX}px`;
                cursor.style.top = `${cursorY}px`;
                cursor.style.opacity = 1;
                cursor.style.borderColor = '#00d2ff';

                // æ›´æ–° Shader ä¸­çš„æ‰‹éƒ¨ä½ç½®
                // Three.js åæ ‡ç³»: ä¸­å¿ƒ (0,0), å³ x+, ä¸Š y+
                const vecX = (cursorX / window.innerWidth) * 2 - 1; // -1 to 1
                // const vecY = -(cursorY / window.innerHeight) * 2 + 1; // 1 to -1
                // å®é™…ä¸Šå±å¹•åæ ‡ y å‘ä¸‹å¢åŠ ï¼ŒThreeJS y å‘ä¸Šå¢åŠ 
                // æˆ‘ä»¬çš„ç²’å­ç³»ç»Ÿåæ ‡èŒƒå›´å¤§æ¦‚æ˜¯ -250 åˆ° 250

                // ç®€å•æ˜ å°„åˆ°åœºæ™¯åæ ‡
                const sceneX = ((1 - palm.x) - 0.5) * 500; // roughly width of scene
                const sceneY = -(palm.y - 0.5) * 300;
                material.uniforms.uHandPos.value.set(sceneX, sceneY);


                // 1. è·å–æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)çš„è·ç¦» -> æ§åˆ¶ç¼©æ”¾
                const thumb = landmarks[4];
                const indexFinger = landmarks[8];
                const distance = Math.hypot(thumb.x - indexFinger.x, thumb.y - indexFinger.y);

                // æ˜ å°„è·ç¦»åˆ° 0-2 çš„ scale
                // å¢åŠ å¹³æ»‘åº¦ï¼šå¦‚æœå˜åŒ–å¤ªå‰§çƒˆï¼Œå¯èƒ½æ˜¯è¯¯è§¦ï¼Œå¯ä»¥åšç®€å•çš„ä½é€šæ»¤æ³¢ï¼ˆè¿™é‡Œæš‚ä¸å¤æ‚åŒ–ï¼‰
                // è°ƒæ•´çµæ•åº¦ï¼š(distance - 0.05) * 6
                const scaleVal = Math.max(0, (distance - 0.05) * 6);

                // åªæœ‰åœ¨éè‡ªåŠ¨æ’­æ”¾æ¨¡å¼ä¸‹ï¼Œæˆ–æ‰‹åŠ¨ä»‹å…¥æ—¶æ‰ç”Ÿæ•ˆ? 
                // ç°åœ¨çš„é€»è¾‘æ˜¯ï¼šæ‰‹åŠ¿å§‹ç»ˆæœ‰æ•ˆï¼Œä¼šå åŠ åœ¨å½“å‰çŠ¶æ€ä¸Š
                gsap.to(material.uniforms.uScale, { value: scaleVal, duration: 0.3 });
                document.getElementById('spread').value = scaleVal;

                // 2. ç§»é™¤æŒ¥æ‰‹åˆ‡æ¢é€»è¾‘ï¼Œåªä¿ç•™ç¼©æ”¾

            } else {
                // æ²¡æœ‰æ‰‹çš„æ—¶å€™
                gsap.to(material.uniforms.uScale, { value: 0, duration: 1 });
                cursor.style.opacity = 0;
            }
        }

        function initMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            hands.onResults(onResults);

            const cameraFeed = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cameraFeed.start();
        }

        let isRotating = false;
        function toggleRotation(enabled) {
            isRotating = enabled;
        }

        /**
         * 6. æ¸²æŸ“å¾ªç¯ä¸ UI é€»è¾‘
         */
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            if (material) material.uniforms.uTime.value = time;

            if (isRotating) {
                particles.rotation.y += 0.002;
            }

            // é‡‘é’±æ‰è½é€»è¾‘
            if (moneySystem && moneySystem.userData.active) {
                const positions = moneySystem.geometry.attributes.position.array;
                const speeds = moneySystem.geometry.attributes.speed.array;
                const axes = moneySystem.geometry.attributes.axis.array;
                const angles = moneySystem.geometry.attributes.angle.array;

                for (let i = 0; i < 300; i++) {
                    // ä¸‹è½
                    positions[i * 3 + 1] -= speeds[i];

                    // å·¦å³æ‘‡æ‘†
                    positions[i * 3] += Math.sin(time * 2 + i) * 0.5;

                    // æ—‹è½¬æ•ˆæœ (è¿™é‡Œå®é™…ä¸Šæ— æ³•æ—‹è½¬ Point çº¹ç†æœ¬èº«ï¼Œé™¤éç”¨ ShaderMaterialï¼Œä½†ä¸ºäº†ä¿æŒé‡‘é’±çš„é—ªçƒæ„Ÿï¼Œæˆ‘ä»¬è®©å®ƒå¤§å°ç•¥å¾®å˜åŒ–)
                    // å¦‚æœè¦çœŸæ—‹è½¬ï¼Œéœ€è¦æ¢ Mesh æˆ– Spriteï¼Œä½† Points æ€§èƒ½æœ€å¥½ã€‚
                    // è¿™é‡Œçš„ compromise:
                    if (positions[i * 3 + 1] < -200) {
                        positions[i * 3 + 1] = 200;
                        positions[i * 3] = (Math.random() - 0.5) * 400;
                    }
                }
                moneySystem.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // UI Helper Functions
        let sortable;
        function updateSceneListUI() {
            const list = document.getElementById('scene-list');
            list.innerHTML = '';
            SCENES.forEach((s, i) => {
                const div = document.createElement('div');
                div.className = `scene-item ${i === currentSceneIndex ? 'active' : ''}`;
                div.setAttribute('data-index', i); // ç»‘å®šç´¢å¼•

                // Drag Handle
                const handle = document.createElement('span');
                handle.innerHTML = 'â˜°';
                handle.style.marginRight = '10px';
                handle.style.cursor = 'grab';
                handle.style.color = '#555';
                div.appendChild(handle);

                const spanName = document.createElement('span');
                spanName.innerText = s.name;
                spanName.style.flex = "1";
                div.appendChild(spanName);

                // Duration input (small)
                const durInput = document.createElement('input');
                durInput.type = 'number';
                durInput.min = '1';
                durInput.max = '60';
                durInput.value = s.duration || 3;
                durInput.style.width = '40px';
                durInput.style.marginRight = '5px';
                durInput.style.background = 'rgba(0,0,0,0.3)';
                durInput.style.border = '1px solid rgba(255,255,255,0.2)';
                durInput.style.color = '#fff';
                durInput.style.borderRadius = '4px';
                durInput.style.fontSize = '12px';
                durInput.style.textAlign = 'center';
                durInput.onclick = (e) => e.stopPropagation();
                durInput.onchange = (e) => {
                    s.duration = parseFloat(e.target.value);
                    // å¦‚æœæ­£åœ¨è‡ªåŠ¨æ’­æ”¾ä¸”å½“å‰æ­£åœ¨æ’­æ”¾æ­¤åœºæ™¯ï¼Œéœ€è¦é‡ç½®å®šæ—¶å™¨ä»¥ç«‹å³ç”Ÿæ•ˆ
                    if (i === currentSceneIndex && document.getElementById('autoplay-toggle').checked) {
                        if (autoPlayInterval) clearTimeout(autoPlayInterval);
                        scheduleNextSlide();
                    }
                };
                div.appendChild(durInput);

                const spanSec = document.createElement('span');
                spanSec.innerText = 's';
                spanSec.style.fontSize = '10px';
                spanSec.style.marginRight = '8px';
                spanSec.style.color = '#666';
                div.appendChild(spanSec);

                // Delete button for custom scenes (index >= 9 because DEFAULT_SCENES length is 9 now)
                // But since we allow editing the list order or content, let's just say we can delete anything that is 'custom_text' or added later.
                // For simplicity in this demo: allow deleting any scene except the first one to avoid empty list
                if (SCENES.length > 1) {
                    const delBtn = document.createElement('button');
                    delBtn.className = 'del-btn';
                    delBtn.innerHTML = 'Ã—';
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteScene(i);
                    };
                    div.appendChild(delBtn);
                }

                div.onclick = () => morphTo(i);
                list.appendChild(div);
            });

            // Init Sortable
            if (!sortable) {
                sortable = new Sortable(list, {
                    animation: 150,
                    handle: 'span:first-child', // use the handle
                    ghostClass: 'sortable-ghost',
                    onEnd: function (evt) {
                        // Reorder SCENES array
                        const item = SCENES.splice(evt.oldIndex, 1)[0];
                        SCENES.splice(evt.newIndex, 0, item);

                        // Update current index if needed
                        if (currentSceneIndex === evt.oldIndex) {
                            currentSceneIndex = evt.newIndex;
                        } else if (currentSceneIndex > evt.oldIndex && currentSceneIndex <= evt.newIndex) {
                            currentSceneIndex--;
                        } else if (currentSceneIndex < evt.oldIndex && currentSceneIndex >= evt.newIndex) {
                            currentSceneIndex++;
                        }

                        // Refresh UI to update indices
                        updateSceneListUI();
                    }
                });
            }
        }

        function handleAddScene() {
            const type = document.getElementById('add-type-select').value;

            if (type === 'custom_text') {
                const text = prompt("è¯·è¾“å…¥è¦æ˜¾ç¤ºçš„æ–‡å­— (æ”¯æŒå¤šè¡Œï¼Œç”¨æ¢è¡Œç¬¦åˆ†éš”):", "Hello\nWorld");
                if (text) {
                    SCENES.push({ name: text.replace(/\n/g, ' '), type: 'custom_text', content: text, duration: 3 });
                    finishAdd();
                }
            } else {
                // æ˜ å°„åç§°
                const nameMap = {
                    'sphere': 'æ˜Ÿäº‘çƒä½“',
                    'cube': 'é‡å­ç«‹æ–¹',
                    'torus': 'è«æ¯”ä¹Œæ–¯ç¯',
                    'dna': 'åŒèºæ—‹ DNA',
                    'heart': 'çˆ±å¿ƒé‡‘å¸',
                    'galaxy': 'é“¶æ²³èºæ—‹',
                    'wave': 'ç²’å­æ³¢æµª',
                    'ring': 'åœŸæ˜Ÿå…‰ç¯'
                };
                SCENES.push({ name: nameMap[type], type: type, duration: 3 });
                finishAdd();
            }
        }

        function finishAdd() {
            updateSceneListUI();
            morphTo(SCENES.length - 1);
        }

        function deleteScene(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåœºæ™¯å—ï¼Ÿ')) {
                SCENES.splice(index, 1);
                if (currentSceneIndex >= index) {
                    currentSceneIndex = Math.max(0, currentSceneIndex - 1);
                }
                updateSceneListUI();
                morphTo(currentSceneIndex);
            }
        }

        function saveScenes() {
            localStorage.setItem('lizi_scenes', JSON.stringify(SCENES));
            alert('åœºæ™¯é…ç½®å·²ä¿å­˜ï¼');
        }

        function resetScenes() {
            if (confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤åœºæ™¯å—ï¼Ÿæ‰€æœ‰è‡ªå®šä¹‰åœºæ™¯å°†ä¸¢å¤±ã€‚')) {
                localStorage.removeItem('lizi_scenes');
                location.reload();
            }
        }

        function toggleUI() {
            document.getElementById('ui-panel').classList.toggle('collapsed');
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }

        // Auto Play Logic
        let autoPlayInterval;
        let isLoopMode = false; // é»˜è®¤ä¸å¾ªç¯

        function toggleLoopMode(enabled) {
            isLoopMode = enabled;
        }

        function toggleAutoPlay(enabled) {
            if (enabled) {
                // å¼€å¯æ—¶å…ˆæ¸…é™¤æ—§çš„
                if (autoPlayInterval) clearTimeout(autoPlayInterval);
                scheduleNextSlide();
            } else {
                if (autoPlayInterval) clearTimeout(autoPlayInterval);
            }
        }

        function scheduleNextSlide() {
            // è·å–å½“å‰åœºæ™¯çš„åœç•™æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®é»˜è®¤ 3 ç§’
            // æ³¨æ„ï¼šcurrentSceneIndex å¯èƒ½å› ä¸ºæ‹–æ‹½è€Œå˜åŒ–ï¼Œè¿™é‡Œå–å½“å‰å®é™…æ¸²æŸ“çš„åœºæ™¯æ•°æ®
            const currentScene = SCENES[currentSceneIndex];

            // é¢„é˜²æ•°ç»„è¶Šç•Œ
            if (!currentScene) return;

            const duration = (currentScene.duration || 3) * 1000;

            autoPlayInterval = setTimeout(() => {
                let nextIndex = currentSceneIndex + 1;

                // å¦‚æœå·²ç»åˆ°è¾¾æœ€åä¸€é¡µ
                if (nextIndex >= SCENES.length) {
                    if (isLoopMode) {
                        nextIndex = 0;
                    } else {
                        // ä¸å¾ªç¯ï¼Œåœæ­¢æ’­æ”¾
                        nextIndex = SCENES.length - 1;
                        document.getElementById('autoplay-toggle').checked = false;
                        return;
                    }
                }
                morphTo(nextIndex);

                // ç»§ç»­è°ƒåº¦ä¸‹ä¸€æ¬¡ (å¦‚æœè¿˜åœ¨è‡ªåŠ¨æ’­æ”¾æ¨¡å¼)
                if (document.getElementById('autoplay-toggle').checked) {
                    scheduleNextSlide();
                }

            }, duration);
        }

        // Color Listeners
        document.getElementById('colorA').addEventListener('input', (e) => {
            CONFIG.colorA.set(e.target.value);
            material.uniforms.uColorA.value = CONFIG.colorA;
        });
        document.getElementById('colorB').addEventListener('input', (e) => {
            CONFIG.colorB.set(e.target.value);
            material.uniforms.uColorB.value = CONFIG.colorB;
        });

        // Window Resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Start
        initThree();
        initMediaPipe();
        // é»˜è®¤å¼€å¯è‡ªåŠ¨æ’­æ”¾
        toggleAutoPlay(true);

    </script>
</body>

</html>
